# 前言：

#### 需要掌握的点：

- JVM java内存结构
- 垃圾回收机制算法
- Jvm中如何判断对乡村会
- GC日志
- 基本参数调优
- 基本性能检测工具
- 垃圾回收机制 串行回收和并行回收 垃圾收集
- 类加载器（ClassLoder）



#### 文档存在的问题：

- 需要结合书和word整理

> 感觉架构的视频就像书对培训班知识的补充，有一个人带着理解确实方便很多。但是看书还是有必要的，看过视频后看书，会比直接看书轻松很多。

# 一、什么是JVM？

### 1.1 HotSpot VM

&emsp;&emsp;根据word去整理总结！



# 二、Java内存结构

![1566983128874](img\1566983128874.png)



# 三、垃圾回收机制算法分析

### 3.1 什么是垃圾回收机制

&emsp;&emsp;JVM自动不定时的**回收不可达【不可访问】的对象**。垃圾回收系统是Java的核心，也是不可少的，Java有一套自己进行垃圾清理的机制，开发人员无需手动清理。

&emsp;&emsp;不可达就是对象不再被引用。



### 3.2 finalize方法

&emsp;&emsp;垃圾回收机制之前会进行执行的方法，`gc`后并不一定会即时回收。



### 3.3 新生代和老年代

&emsp;&emsp;堆内存划分为新生代【又分为`EDEN`、`S0=S1`区(用于复制和交换)】和老年代，默认的**化为比例为1：2【新生代：老年代】**

&emsp;&emsp;**新生代：**用于存放刚出生不久的对象，不是经常使用的对象。【垃圾回收频繁】

&emsp;&emsp;**老年代：**用于存放比较活跃的对象，经常被引用。



![1566993305107](img\1566993305107.png)



### 3.4 引用计数法判断对象是否存活

&emsp;&emsp;相当于每个对象有一个年龄【默认为0】，如果小于或者等于15，存放在新生代。如果大于15就会存放在老年代。如果对象被引用的话，年龄就会加1，如果没有被继续使用回收年龄减1。GC线程不定时进行回收时，如果为0就回收。

&emsp;&emsp;存在循环以来的问题，已经被淘汰。



### 3.5 根搜索（GC Roots）

&emsp;&emsp;在根搜索机制中，可达对象需要和根节点有依赖关系。如果没有和`GC roots`有任何引用的情况下，就说是不可达对象。

&emsp;&emsp;**GC Roots对象包括以下几种【Java中】：**

- 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
- 方法区中的类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中**JNI(Native方法)**引用的对象。



### 3.6 垃圾回收机制策略

&emsp;&emsp;多用于老年代。

#### 3.6.1 标记清除算法

1. **标记清除算法的两个阶段：**
   - **标记阶段**：找到所有可访问的对象，做个标记。
   - **清除阶段**：遍历堆，把未被标记的对象回收。
2. **标记清楚算法的优缺点：**
   - 优点：
     - 可以解决循环引用问题
     - 必要时才回收（内存不足时）
   - 缺点：
     - 回收时，应用需要挂起。也就是`stop hte world`
     - 效率不该，尤其是要扫描对象比较多是。
     - **会造成内存碎片化**。【明明有内存，但是不连续，申请占用内存大的对象可能无法做到】



#### 3.6.2 复制算法

&emsp;&emsp;一开始会将可用内存分成两块，`from`区和`to`区。每次只使用`from`区，开始`GC`操作时，这个时候会将存活的对象复制到`to`区，然后清理整个`from`区。【解决了碎片化问题，能够很快清理】



1. **优点与缺点**
   - 优点：能够解决碎片化问题，快速，清理干净。
   - 缺点：浪费了部分空间
2. **总结**：GC回收将可达对象复制到下一个区域，然后直接清除当前区域所有对象。



#### 3.6.3 标记压缩算法

&emsp;&emsp;标记清除和标记压缩是很相似的，标识压缩算法呢解决了碎片化的问题。会在做清理的时候整理内存。

1. **压缩算法简单介绍**
   - **任意顺序**：几部考虑原先对象排列顺序，也不考虑引用关系，随意移动对象。
   - **线性顺序**：考虑引用关系，如果a引用了b，就尽可能让两个对象移动到一块。
   - **滑动顺序**：按照对象原来在堆中的顺序滑动到堆的一端。

2. **优点和缺点**：
   - **优点**：解决内存碎片问题。
   - **缺点**：压缩阶段，由于移动了可用对象，需要去更新引用。



#### 3.6.4 分代算法

&emsp;&emsp;根据对象的生存周期将内存空间划分，针对于不同的空间使用不用的算法

1. **Minor GC和Full GC的区别**
   - **新生代 GC【Minor GC】**：指发生在新生代的垃圾收集动作，回收比较频繁，回收的速度也比较快。
   - **老年代 GC【Major GC/Full GC】**：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor Gc【并非绝对】。速度一般会比新生代GC慢10倍以上。

> 注：`Full GC`会清理永久代【Java移除】，当永久代满了的时候，就会触发`Full GC`

