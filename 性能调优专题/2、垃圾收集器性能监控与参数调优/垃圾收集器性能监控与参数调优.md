# 前言：



#### 遇到的问题：

- Jvm方法区为什么不用配置，视频中没有说明。后续百度
- 新生代内的配置没有说清楚。后期添加具体说明。





# 一、JVM参数配置



### 1.1  常见参数配置

| 参数                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| `-XX:+PrintGC`        | 每次触发GC时打印相关日志                                     |
| `-XX:+UseSerialGC`    | 串行回收                                                     |
| `-XX:+PrintGCDetails` | 更详细的GC日志                                               |
| `-Xms`                | 堆初始值                                                     |
| `-Xmx`                | 对最大可用值【默认4G】（尽量与初始值一致）                   |
| `-Xmn`                | 新生代堆最大可用值                                           |
| `-XX:SurvivorRatio`   | 用来设置新生代中`eden`,`from/to`区的空间比例【一般`eden=from+to`】 |
| `-XX:NewRatio`        | 配置新生代与老年代占比。【一般`1：2`默认也是】               |

>&emsp;&emsp;在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。【如果初始值过小，会 频繁回收和申请内存】
>
>&emsp;&emsp;新生代和老年代的比例尽量小，让程序多在新生代去回收，老年代尽量不去回收。【`1：2`比较好】



### 1.2 配置Jvm堆内存大小

> 调优主要就是配置堆内存。



#### 1.2.1 打印堆的基本信息

```java
public class PrintInfo{
    public static void main(String args){
        System.out.println("最大内存：" + (Runtime.getRuntime().maxMemory() / 1024 / 1024) + "M");
        System.out.println("可用内存：" + (Runtime.getRuntime().freeMemory() / 1024 / 1024) + "M");
        System.out.println("已经使用内存：" + (Runtime.getRuntime().totalMemory() / 1024 / 1024) + "M");
    }
}
```



#### 1.2.2 更改初始内存大小和最大内存 大小

&emsp;&emsp;使用示例: ` -Xmx20m -Xms5m `

&emsp;&emsp;说明：最大内存为20M，初始内存为5M 

> 此时观察控制台初始，可以使用`byte`数组来测试，观察控制台变化



#### 1.2.3 配置新生代比例参数

&emsp;&emsp;使用示例：`-Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC`

&emsp;&emsp;说明：最大内存20，初始20，新生代最大值1m。**eden与from/to**的比例**是2/1**【`2：1：1`】

>  默认情况，`eden：s0:s1`是`8：1：1`，s0/1主要是做复制的配置特别大会占用内存。具体应该视情况而定。



#### 1.2.4 设置新生代与老年代比例

&emsp;&emsp;使用示例: `-Xms20m -Xmx20m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC -XX:NewRatio=2`

&emsp;&emsp;说明：堆内存，初始最大为20m，eden与from/to的比例2/1，新生代和老年代的占比1/2



### 1.3 解决内存溢出问题



#### 1.3.1 Java堆溢出

&emsp;&emsp;错误异常：`java.lang.OutOfMemoryError`: `Java heap space` 堆内存溢出

&emsp;&emsp;解决办法：【配置Jvm虚拟机空间】`-Xms1m -Xmx10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError`

| 参数                              | 说明                           |
| --------------------------------- | ------------------------------ |
| `-XX:+HeapDumpOnOutOfMemoryError` | 导出内存溢出的堆信息(hprof文件 |

> 当老年代，方法区内存不足，就会进行Full GC对内存进行一个全面的回收。老年代回收必定触发新生代回收【并不是所有虚拟机】



#### 1.3.2 虚拟机栈溢出

&emsp;&emsp;错误原因：`java.lang.StackOverflowError`  栈内存溢出

&emsp;&emsp;解决办法：`Xss5m` 设置最大调用深度【默认：10636（可能不同），配置成`1m`大概是`10805`】

> 栈溢出产生于递归调用。递归的深度达到一定程度报错。



#### 1.3.3 内存溢出和内存泄漏的区别

&emsp;&emsp;**内存溢出**，在申请内存空间时，超出最大堆内存空间。**内存泄露**，是因为内存空间没有及时的释放，长时间占用内存，最终导致内存溢出。**内存泄漏**同常在静态变量，io，常量等等过多时产生。



> **GC机制回收原则**：减少回收次数和回收时间



# 二、垃圾收集器



### 2.1 并行与串行收集器

&emsp;&emsp;串行回收：JDK1.5前的默认算法，缺点是只有一个线程，执行垃圾回收时程序停止的时间比较长。

&emsp;&emsp;并行回收：多线程执行垃圾回收适合于吞吐量的系统【高并发项目】，回收时系统会停止运行。



### 2.2 serial收集器

&emsp;&emsp;最古老的串行收集器，最稳定以及效率高的收集器，可能会产生较长的停顿。只有一个线程回收。Cpu利用率最高，适用于小型项目。使用了复制算法、标记清除、标记压缩。

> 通过JVM参数`-XX:+UseSerialGC`可以使用串行垃圾回收器



### 2.3 ParNew收集器

&emsp;&emsp;`serial`的多线程版本，新生代并行，老年代串行。

**参数控制：**

- `-XX:+UseParNewGC`：  使用ParNew收集器
- `-XX:ParallelGCThreads` ：限制线程数量



### 2.4 parallel收集器

&emsp;&emsp;Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开**自适应调节策略**，虚拟机会根据当前系统的运行情况**收集性能监控信息**，**动态调整这些参数以提供最合适的停顿时间或最大的吞吐量**；也可以通过参数控制GC的时间不大于多少毫秒或者比例；**新生代复制算法、老年代标记-压缩**

&emsp;&emsp;**特点**：停顿时间短，回收效率高，对吞吐量要求高。
&emsp;&emsp;**适用场景**：大型应用，科学计算，大规模数据采集等。



**参数配置：**

- `-XX:+UseParallelGC`：使用parallel收集器



### 2.5 CMS收集器

&emsp;&emsp;在Jdk1.7推出，是一种获取最短停顿时间为目标的收集器。适用于`B/S`架构。大型服务器等。

&emsp;&emsp;特点：响应时间优先，减少垃圾收集停顿时间



**参数配置：**

- `-XX:+UseConcMarkSweepGC`：使用CMS收集器



### 2.6 g1收集器

&emsp;&emsp;在`g1`中，堆被划分成许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。



**特点：**

- 支持很大的堆，高吞吐量
- 支持多CPU和垃圾回收线程
- 在主线程暂停的情况下，使用并行收集
- 在主线程运行的情况下，使用并发收集



**实时目标：**可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收

**参数配置：**`-XX:+UseG1GC`：使用G1垃圾回收器

> 并发和并行的区别：
>
> - 并发：同时进行，指多个处理器或者是多核的处理器同时处理多个不同的任务
> - 并行：并发是指一个处理器同时处理多个任务
>
> 并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。



# 三、Tomcat配置调优测试

> 调优原则，减少垃圾回收次数，尽可能增大老年代空间

### 3.1 Jmeter压力测试工具

&emsp;&emsp;Mac下直接下载`tar`包解压后进入`bin`直接`sh Jmeter`运行

**使用步骤**：

- 添加线程组，配置线程数
- 配置循环次数
- 添加**Http请求**取样器
- 添加**聚合报告**监听器

##### 3.1.1 报告参数对应的含义

| 参数 | 含义 |
| ---- | ---- |
|      |      |

> 堆的初始内存对吞吐量的影响比较大，将初始内存和最大内存配置为一样性能最好。**【垃圾回收次数与最大内存无关】**
>
> 总结：
>
> - 初始堆值和最大堆内存内存越大，吞吐量就越高。
>
> - 最好使用并行收集器,因为并行收集器速度比串行吞吐量高，速度快。
>
> - 设置堆内存新生代的比例和老年代的比例最好为1:2或者1:3。
>
> - 减少GC对老年代的回收



### 3.1 公司中的性能调优过程

- 写测试报告【性能检测报告】，测试服务器，一定要与生产环境相同
- 根据测试报告调优

# 四、JDK可视化工具

### 4.1 JConsole

&emsp;&emsp;JConsole 是一个内置 Java 性能分析器，可以从命令行或在 GUI shell 中运行。您可以轻松地使用 JConsole（或者，它更高端的 “近亲” VisualVM ）来监控 Java 应用程序性能和跟踪 Java 中的代码。

##### 4.1.1 JConsole检测死锁

&emsp;&emsp;连接后直接进入线程选项卡检测即可。



### 4.2 visualVm

&emsp;&emsp;VisualVM 是一款免费的，集成了多个 JDK 命令行工具的可视化工具，它能为您提供强大的分析能力，对 Java 应用程序做性能分析和调优。这些**功能**包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析，同时它还支持在 MBeans 上进行浏览和操作。

&emsp;&emsp;相对于`JConsole`相比增加了垃圾回收次数等等。更能更佳丰富。88

