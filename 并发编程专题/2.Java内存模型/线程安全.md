# 前言：

#### 需要扩展的内容：

- synchronized实现原理。
- ThreadLocal的内存泄漏问题

#### 对应的java文件

- ThreadSafety_Deadlock：死锁问题
- ThreadSafety_ThreadLocal：使用threadLocal
- ThreadSafety_Tickets：线程安全问题：火车票例子。
- ThreadSafety_Volatile：volatile演示

# 一、什么是线程安全问题

> 多个线程操作一个全局变量时，产生的问题。【读是不会发生】



# 二、如何解决线程安全问题

### 2.1 内置锁（synchronized）：

#### 2.1.1 特点：

- 保证线程原子性
- 多线程进入方法的时候，自动获取锁，一旦锁被其他线程获取后，其他线程就会等待

#### 2.1.2 锁的特征：

- 只能有一个线程进行使用。程序执行完毕释放锁。会降低程序运行效率。
- 没有拿到锁的线程会进入就绪状态，锁资源需要竞争。
- 可传递使用【重入锁】。
- 互斥锁【单一线程使用】

> 重入锁：拿到了锁之后，如果嵌套了同一把锁，不需要在获取。直接使用

#### 2.1.3 内置锁的两种使用方式

- 同步方法：锁住当前方法，只能有一个线程进入此方法【本质还是同步代码块】

  - 非静态同步：锁住当前对象，this锁
  - 静态同步：锁住当前类的字节码对象。`.class`

- 同步代码块：【最好使用同步代码块】

  ```java
  synchronized(任意全局对象){
  	;//被同步的内容
  }
  ```

  > **一定要用同一把锁**：创建两个对象时，如果锁的是非静态对象那么根本不管用。
  >
  > 切记！！！ 不同对象同步时，锁住的对象和共享变量都需要是静态的



#### 2.1.4 证明非静态同步方法就是this锁

#### 2.1.5 证明静态同步方法锁住的是字节码

> 通过synchronized的互斥性证明。【ThreadSafety_Tickets文件可以说明】



### 2.2 多线程死锁

> 一般都在同步中嵌套同步时产生

【ThreadSafety_Deadlock.java中详细说明】



### 2.2 显示锁（Lock锁）:

&emsp;&emsp;在*多线程之间的通信*中

# 三、线程的局部变量【ThreadLocal<T\>】

### 3.1 什么是ThreadLocal

&emsp;&emsp;给每个线程提供局部变量【每个线程私有】，解决线程安全问题 

> 使用时直接new对象就能使用。【好的做法是在类中静态实现】

### 3.2 ThreadLocal的方法

| 方法名                            | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `void set(Object v)`              | 设置当前线程的线程局部变量的值                               |
| `public Object get()`             | 返回当前线程所对应的线程局部变量                             |
| `public void remove()`            | 将当前线程局部变量的值删除【加快内存回收，线程结束也会回收】 |
| `protected Object initialValue()` | 返回该线程局部变量的初始值【protected的方法，为了覆写设计】，默认返回值为`null`，只有第一次调用`set()`或`get()`时执行 |



> ThreadLocal的底层实现就是Map



# 四、多线程三大特性

#### 4.1 原子性

&emsp;&emsp;原子性就是保证数据一致，线程安全的一部分。

#### 4.2 可见性

&emsp;&emsp;多线程访问，一个线程修改了值，其他线程能够立即看得到修改的值。

#### 4.3 有序性

&emsp;&emsp;程序执行的顺序按照代码的先后顺序执行。



# 五、Java内存模型

> 网上误导：内存模型谈到堆、栈概念【java内存结构】
>
> 内存模型：`jmm`是一个多线程相关内容，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。【并不真实存在，只是概念】



#### 5.1 java内存模型【jmm】的作用

&emsp;&emsp;jmm决定一个线程对共享变量的写入时，能对另一个线程是否可见。

#### 5.1 java主内存与工作内存

- 主内存：共享存储的变量

- 本地内存【工作内存】：共享变量的副本

导致线程安全问题的原因：

![1563024738767](img\1563024738767.png)

> `jmm【白话说明】`：
>
> - 就是多线程通信时，通过本地内存刷新到主内存，另一线程再从主内存读取到其本地内存。
>
> `产生的问题`：
>
> - 会有内存不能及时刷新到主内存的可能，就会出现线程安全问题



> 主内存和方法区有点像但不是一个概念里的东西



# 六、Volatile关键字

#### 6.1 作用：

&emsp;&emsp;保证线程的可见性，**直接更改进主内存中，且每次使用先都从主内存中刷新**。【使用后会影响重排序】

> 注意：只能保证可见性，不能保证原子性，`synchronized`既可以保证原子性，又可以保证可见性



#### 6.2 volatile 性能：

&emsp;&emsp;volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。



#### 6.3 禁止指令重排序优化【了解】：

&emsp;&emsp;有volatile修饰的变量，赋值后多执行了一个“`load addl $0x0, (%esp)`”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理



# 七、重排序

#### 7.1 重排序简单理解

&emsp;&emsp;cpu会对代码实现执行优化。不会对有依赖关系的做重排序。——也就是说执行顺序可能会发生变化。

> `重排序问题`：
>
> &emsp;&emsp;一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它**不保证程序中各个语句的执行先后顺序同代码中的顺序一致**，但是**它会保证程序最终执行结果和代码顺序执行的结果是一致的**。如下：
>
> int a = 10;    //语句1
>
> int r = 2;    //语句2
>
> a = a + 3;    //语句3
>
> r = a*a;     //语句4
>
> 则因为重排序，他还可能执行顺序为 2-1-3-4，1-3-2-4
> 但绝不可能 2-1-4-3，因为这打破了依赖关系。
> 显然**重排序对单线程运行是不会有任何问题**，而**多线程就不一定了**，所以我们在多线程编程时就得考虑这个问题了。



#### 7.2 as-if-serial语义

&emsp;&emsp;不管怎么重排序，目的是提高并行度，但不能影响正常的结果。

> 重排序一般在多线程的情况下遇到，单线程一般遇不到。【并行执行时才会受到影响，单线程也会重排序】



#### 7.3 重排序对程序的影响

```java
/**
 * 重排序问题,假设有两个线程
 */
class ReorderExample {
    int a = 0;
    boolean flag = false;

    /**
     * 写入线程
     */
    public void writer() {
        a = 1;                   //1
        flag = true;             //2

        //1、2没有依赖关系，所以会重排序 i就有可能为0

    }
    //正常情况下应该 i = 1

    /**
     * 读取线程
     */
    public void reader() {
        if (flag) {                //3
            int i = a * a;        //4
        }
    }
}
```

